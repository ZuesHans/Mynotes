# 题目整理

[TOC]

##  练习题
>这里收录着各种练习题，可能是由更好的思路或是我根本不会


### P1067 [NOIP 2009 普及组] 多项式输出

- **题号**: P5678
- **链接**: [题目链接](https://www.luogu.com.cn/problem/P1067)
- **算法类型**: 模拟
- **错误原因**:
  - 分类讨论大师，不读题导致的
  - 这道题需要特判0，1，最高次项
  - 一开始把下标和数字分开处理使非常愚蠢的做法！
- **AC 代码**:
```cpp
for (int i = n, j = 0; i >= 0; i--, j++) // 以后两个变量都写在这里
bool fh = (nums[j] > 0);
bool notOne = (nums[j] != 1);
bool isfuOne = (nums[j] == -1);
```
- **注意事项**:
  - 读题读题读对题
  - 想好再写
  - 模拟题一定要有耐心，认真讨论所有可能的条件
  - bool变量是对的！分讨大师请多多使用bool变量做分叉
  - 记得特判要continue，想好在什么时候刷新判断


### P4924  魔法少女小Scarlet

- **题号**: P4924
- **链接**: [题目链接](https://www.luogu.com.cn/problem/P4924)
- **算法类型**: 模拟
- **错误原因**:
  - 乍一看很复杂，要不是定级只有橙我肯定跳了
  - 这告诉我们不管什么题都一定要用心想，万一错过一道模拟唐题呢
  - 我不行了ljl当年做这题20分钟就调完了，太可怕了，学了40天有这么好的基础
- **AC 代码**:
```cpp

```
- **注意事项**:
  - 不能畏难！不要偷懒！不要看到一道没有处理过的情况就逃避
  - 这种修改数组相对位置想一下能不能通过坐标一一映射解决
  - 可不可以从简单的修改例子（比如3*3的矩阵开始）来找到通解
  - 能不能将大问题拆分成重复处理的单元问题，能不能把特殊问题处理成一般的规律
  
  ### 爬楼梯

- **题号**: P5678
- **链接**: [题目链接](https://www.luogu.com.cn/problem/P5678)
- **算法类型**: 高精度，递归
- **错误原因**:
  - 因为高精度不能用dp
  - 状态转移方程能错真是神人
- **AC 代码**:
```cpp

```
- **注意事项**:
  - 注意数据范围
  - 数据范围：检查输入范围 $ N $ 是否会导致结果超出常用整数类型的上限。

>如果 $ N \leq 50 $，结果可能还在 64 位整数范围内（视具体语言而定）。
如果 $ N $ 较大（例如 $ N \geq 100 $），斐波那契数列的数值会快速增长，超出 $ 10^{18} $，需要高精度。


>题目提示：题目提到“对于 60% 的数据，$ N \leq 50 $”，暗示当 $ N $ 较大时（接近 5000），需要特殊处理，通常是高精度计算。
结果的规模：如果预期输出可能达到几十位或更多位，就需要高精度。例如，$ f(5000) $ 可能有上千位。
- **改进思路**:
  - 


### P2280 [HNOI2003] 激光炸弹

- **题号**: P2280
- **链接**: [题目链接](https://www.luogu.com.cn/problem/P2280)
- **算法类型**: 二维差分
- **算法**:
  - 二维差分的适用性
> **离散化地图**：目标点的坐标 $(x_i, y_i)$ 分布在 $0 \leq x_i, y_i \leq 5000$ 的整数格点上，可以用一个二维数组 $sum[x][y]$ 记录每个格点 $(x, y)$ 的总价值（可能有多个目标点在同一位置）。
>**区域和计算**：对于一个正方形区域 $[x, x+m-1] \times [y, y+m-1]$，我们需要快速计算这个矩形区域内所有点的价值和。直接遍历点的时间复杂度为 $O(n)$，而通过二维前缀和或二维差分，可以将区域和的计算优化到 $O(1)$ 或接近 $O(1)$。
  - 二维前缀和方程（自推）
~~~
   pre[i][j]=pre[i][j-1]+pre[i-1][j]-pre[i-1][j-1]
~~~
- **代码错误**
 >无偏移的问题：
 >>**“边界不摧毁”对你的代码没有影响**，问题出在别处。
错误细节：坐标范围：0 ~ 5000。
> - 对于 m=1，右下角最小应为0（单点覆盖），但你从1开始，漏掉坐标0的单点。
样例中有点(0,0)和(1,1)，你只算到(1,1)，碰巧输出1（过了样例），但如果测试点只有(0,0)或依赖低坐标，必然错。
> - 对于更大m，如果目标集中在x=0 ~ m-2，需要左上=0的正方形来覆盖，你也漏了。

  简单来说，你的原代码从 *int j = m* 开始，导致至少从 *（1，1）*开始查找，会导致漏掉边界数据

- **AC 代码**:
```cpp

for (int i = 1; i <= 5001; i++)
    {
        for (int j = 1; j <= 5001; j++) // i是列j是行记得记得别搞乱了
        {
            if (i == 1 && j == 1)
                continue;
            dbg(i, j);
            if (i == 1)
            {
                arr[1][j] = arr[1][j - 1] + arr[1][j];
                continue;
            }
            if (j == 1)
            {
                arr[i][1] = arr[i - 1][1] + arr[i][1];
                continue;
           }
            arr[i][j] = arr[i][j - 1] + arr[i - 1][j] - arr[i - 1][j - 1] + arr[i][j];
        }
    }
    int ans = 0;
    for (int i = m; i <= 5001; i++)
    {
        for (int j = m; j <= 5001; j++) // i是列j是行记得记得别搞乱了
        {
            int hsh = arr[i][j] - arr[i - m][j] - arr[i][j - m] + arr[i - m][j - m];
            ans = max(ans, hsh);
        }
    }
    cout << ans;

```
- **注意事项**:
  - 
- **改进思路**:
  - 二维差分适合这道题，因为它能高效处理二维平面上的矩形区域和问题，通过预处理将区域和查询优化到 $O(1)$，总复杂度可控
---
## 赛后补题
>这里收录着各场比赛的赛后总结。或许有赛时代码优化掉落

### 2025年10月19日广工新生月赛
- **名次** A赛道第四，C赛道第一，总榜第十三（成功！第一次参加比赛结果还算可以）
- **存在问题** 码力羸弱，很多题都是用的巧法做。需补算法。心态不稳，乱交答案罚时爆炸痛失金牌

#### K最不上升也降序列

- **题号**: K
- **链接**: [题目链接](https://ac.nowcoder.com/acm/contest/119605/J)
- **算法类型**: 数学证明
- **错误原因**:
   - 不会
   - 都错题了（byd）题目中的LIS指的是**最长**单增子序列
- **题解思路**:
>LIS × LDS ≥ $n$ 是因为排列可以用 LIS 个下降子序列覆盖，每个长度 ≤ LDS，所以 $n \leq$ LIS × LDS。
>在最优构造中，我们让 LIS ≈ LDS ≈ $\sqrt{n}$，使乘积 ≈ $n$（或略大于），从而最小化 LIS + LDS ≈ $2\sqrt{n}$。
>不是“为什么等于 n”，而是“为什么至少 n”，最优构造接近这个下界。
>对于完全平方 n（如 n=9, k=3），乘积正好 =9；否则略大，但不影响。

  
- **AC 代码**:
```cpp

```
- **注意事项**:
  - 注意二分查找的左右边界初始化。
  - 确保 check 函数逻辑正确。

#### 切蛋糕
- **错误原因**:没有错，单纯想要记录天才异或dp
- **题解思路**:
  >建立二维数组，直接模拟遍历切蛋糕，通过队每个（i，j）进行异或运算来记录每个1，1 ->i,j的可行状态。由几何关系可知每个（i，j）的状态仅仅取决于（i-1，j）和（i，j-1）。虽然这道题很简单我的解法比dp更简单更省空间
  >>我想说的是：由一个状态继承过来的做法就可以叫做dp

### 10月22日 牛客练习（新生组）
-**成绩**  六出四（其实应该是我目前能力范围内尽力了）
-**存在问题** 不会快速幂，心态容易炸，时间不够，理论上三角形那题我能出

#### 数三角

- **链接**: [题目链接](https://ac.nowcoder.com/acm/contest/118653/D)
- **算法类型**: 模拟，数学,计算数学，模板
- **错误原因**:
  - 时间不够，这题不是我熟悉的形式，跳过这题
  - 忘记余弦定理了
  - 注意特判三点共线
  - 注意判断一下三条边三个角！！！
- **AC 代码**:
```cpp

bool cek(int i, int j, int k, const vi &x, const vi &y)
{
    int g1 = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);
    int g2 = (x[i] - x[k]) * (x[i] - x[k]) + (y[i] - y[k]) * (y[i] - y[k]);
    int g3 = (x[k] - x[j]) * (x[k] - x[j]) + (y[k] - y[j]) * (y[k] - y[j]);
    int ck = (y[k] - y[i]) * (x[j] - x[i]) - (y[j] - y[i]) * (x[k] - x[i]);
    if (ck == 0)
        return 0;
    if (g1 + g2 - g3 < 0)return 1;
    if (g1 + g3 - g2 < 0) return true;
    if (g2 + g3 - g1 < 0) return true;   
    return 0;
    // ok根据余弦定理我们可以知道只要（a*a+b*b-c*c)*a*b>0就行
}

```
- **注意事项**:
  - 要不然你在开头先声明bool然后结尾在定义运算，要不然你就把数据导入进去，全局变量是坏的
- **改进思路**:
  >这是一种可以套模板的题目，详见以下
  数学公式：
  1，使用叉积公式：点 $(x_0, y_0)$ 到直线（由点 $(x_1, y_1)$ 和 $(x_2, y_2)$ 定义）的距离为：
$$\text{distance} = \frac{|(y_2 - y_1)(x_0 - x_1) - (y_0 - y_1)(x_2 - x_1)|}{\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}}$$
  2，点在多边形内判定
  问题描述：给定多边形（点集按顺序给出）和一个点，判断点是否在多边形内。
  >> 射线法：从点向任意方向（通常水平）射出一条射线，统计与多边形边的交点数。奇数表示点在多边形内，偶数表示在外部。
>注意：处理边界情况（如点在边上或顶点上）。
```cpp 
## 判断三角形类型 ##
bool isObtuse(int x1, int y1, int x2, int y2, int x3, int y3) {
    ll g1 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
    ll g2 = (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3);
    ll g3 = (x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3);
    //这里是叉积判断是否共线
    ll ck = (y3 - y1) * (x2 - x1) - (y2 - y1) * (x3 - x1);
    if (ck == 0) return false;
    return (g1 + g2 - g3 < 0 || g1 + g3 - g2 < 0 || g2 + g3 - g1 < 0);
    //这里是余弦定理返回钝角，直角就==0，锐角就>0
}

## 计算点到直线的距离 ##
double pointToLineDistance(int x0, int y0, int x1, int y1, int x2, int y2) {
    double cross = abs((y2 - y1) * (x0 - x1) - (y0 - y1) * (x2 - x1));
    double dist = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    return cross / dist;
}//注意要用double



```
---
## 总结


